

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ibeis.model.hots.nn_weights &mdash; ibeis 1.4.4 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="ibeis 1.4.4 documentation" href="../../../../index.html"/>
        <link rel="up" title="ibeis.model.hots" href="../hots.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> ibeis
          

          
          </a>

          
            
            
              <div class="version">
                1.4.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ibeis.html">ibeis package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">ibeis</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../../../ibeis.html">ibeis</a> &raquo;</li>
      
          <li><a href="../../model.html">ibeis.model</a> &raquo;</li>
      
          <li><a href="../hots.html">ibeis.model.hots</a> &raquo;</li>
      
    <li>ibeis.model.hots.nn_weights</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ibeis.model.hots.nn_weights</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">utool</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>
<span class="c">#import six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">vtool</span> <span class="kn">as</span> <span class="nn">vt</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">scoring</span>
<span class="c">#from ibeis.model.hots import name_scoring</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">hstypes</span>
<span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">_pipeline_helpers</span> <span class="k">as</span> <span class="n">plh</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span>
<span class="k">print</span><span class="p">,</span> <span class="n">print_</span><span class="p">,</span>  <span class="n">printDBG</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;[nnweight]&#39;</span><span class="p">)</span>


<span class="n">NN_WEIGHT_FUNC_DICT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">MISC_WEIGHT_FUNC_DICT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">EPS</span> <span class="o">=</span> <span class="mf">1E-8</span>


<span class="k">def</span> <span class="nf">_register_nn_normalized_weight_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator for weighting functions</span>

<span class="sd">    Registers a nearest neighbor normalized weighting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">NN_WEIGHT_FUNC_DICT</span>
    <span class="n">filtkey</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">get_funcname</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_fn&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">utool</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;[nn_weights] registering norm func: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filtkey</span><span class="p">,))</span>
    <span class="n">filtfunc</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">nn_normalized_weight</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">filtkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtfunc</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_register_nn_simple_weight_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">filtkey</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">get_funcname</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_match_weighter&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">utool</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;[nn_weights] registering simple func: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filtkey</span><span class="p">,))</span>
    <span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">filtkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_register_misc_weight_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">filtkey</span> <span class="o">=</span> <span class="n">utool</span><span class="o">.</span><span class="n">get_funcname</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;_match_weighter&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">utool</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;[nn_weights] registering simple func: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filtkey</span><span class="p">,))</span>
    <span class="n">MISC_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">filtkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>


<div class="viewcode-block" id="componentwise_uint8_dot"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.componentwise_uint8_dot">[docs]</a><span class="k">def</span> <span class="nf">componentwise_uint8_dot</span><span class="p">(</span><span class="n">qfx2_qvec</span><span class="p">,</span> <span class="n">qfx2_dvec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; a dot product is a componentwise multiplication of</span>
<span class="sd">    two vector and then a sum. Do that for arbitary vectors.</span>
<span class="sd">    Remember to cast uint8 to float32 and then divide by 255**2.</span>
<span class="sd">    BUT THESE ARE SIFT DESCRIPTORS WHICH USE THE SMALL UINT8 TRICK</span>
<span class="sd">    DIVIDE BY 512**2 instead</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr1</span> <span class="o">=</span> <span class="n">qfx2_qvec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">hstypes</span><span class="o">.</span><span class="n">FS_DTYPE</span><span class="p">)</span>
    <span class="n">arr2</span> <span class="o">=</span> <span class="n">qfx2_dvec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">hstypes</span><span class="o">.</span><span class="n">FS_DTYPE</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">qfx2_qvec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="s">&#39;must have normalized sift descriptors here&#39;</span>
    <span class="n">cosangle</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">componentwise_dot</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span> <span class="o">/</span> <span class="n">hstypes</span><span class="o">.</span><span class="n">PSEUDO_UINT8_MAX_SQRD</span>
    <span class="k">return</span> <span class="n">cosangle</span>

</div>
<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="const_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.const_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">const_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; constvote_weight_list = borda_match_weighter(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;constvote_weight_list = %s&#39; % (str(constvote_weight_list),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">constvote_weight_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">K</span>
    <span class="k">for</span> <span class="n">nns</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="n">qfx2_constvote</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="p">),</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">constvote_weight_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_constvote</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">constvote_weight_list</span>

</div>
<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="borda_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.borda_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">borda_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; bordavote_weight_list = borda_match_weighter(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;bordavote_weight_list = %s&#39; % (str(bordavote_weight_list),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bordavote_weight_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">K</span>
    <span class="k">for</span> <span class="n">nns</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="n">qfx2_bordavote</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">bordavote_weight_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_bordavote</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bordavote_weight_list</span>

</div>
<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="cos_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.cos_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">cos_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.nn_weights --test-cos_match_weighter</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;, cfgdict=dict(cos_on=True, K=5, Knorm=5))</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; assert qreq_.qparams.cos_on, &#39;bug setting custom params cos_weight&#39;</span>
<span class="sd">        &gt;&gt;&gt; cos_weight_list = nn_weights.cos_match_weighter(nns_list, nnvalid0_list, qreq_)</span>

<span class="sd">    Ignore:</span>
<span class="sd">        qnid = ibs.get_annot_name_rowids(qaid)</span>
<span class="sd">        qfx2_nids = ibs.get_annot_name_rowids(qreq_.indexer.get_nn_aids(qfx2_idx.T[0:K].T))</span>
<span class="sd">        # remove first match</span>
<span class="sd">        qfx2_nids_ = qfx2_nids.T[1:].T</span>
<span class="sd">        qfx2_cos_  = qfx2_cos.T[1:].T</span>
<span class="sd">        # flags of unverified &#39;correct&#39; matches</span>
<span class="sd">        qfx2_samename = qfx2_nids_ == qnid</span>
<span class="sd">        for k in [1, None]:</span>
<span class="sd">            for alpha in [.01, .1, 1, 3, 10, 20, 50]:</span>
<span class="sd">                print(&#39;-------&#39;)</span>
<span class="sd">                print(&#39;alpha = %r&#39; % alpha)</span>
<span class="sd">                print(&#39;k = %r&#39; % k)</span>
<span class="sd">                qfx2_cosweight = np.multiply(np.sign(qfx2_cos_), np.power(qfx2_cos_, alpha))</span>
<span class="sd">                if k is None:</span>
<span class="sd">                    qfx2_weight = qfx2_cosweight</span>
<span class="sd">                    flag = qfx2_samename</span>
<span class="sd">                else:</span>
<span class="sd">                    qfx2_weight = qfx2_cosweight.T[0:k].T</span>
<span class="sd">                    flag = qfx2_samename.T[0:k].T</span>
<span class="sd">                #print(qfx2_weight)</span>
<span class="sd">                #print(flag)</span>
<span class="sd">                good_stats_ = ut.get_stats(qfx2_weight[flag])</span>
<span class="sd">                bad_stats_ = ut.get_stats(qfx2_weight[~flag])</span>
<span class="sd">                print(&#39;good_matches = &#39; + ut.dict_str(good_stats_))</span>
<span class="sd">                print(&#39;bad_matchees = &#39; + ut.dict_str(bad_stats_))</span>
<span class="sd">                print(&#39;diff_mean = &#39; + str(good_stats_[&#39;mean&#39;] - bad_stats_[&#39;mean&#39;]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Knorm</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">Knorm</span>
    <span class="n">cos_weight_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_qaids</span><span class="p">()</span>
    <span class="c"># Database feature index to chip index</span>
    <span class="k">for</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">nns</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="n">qfx2_qvec</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_vecs</span><span class="p">(</span><span class="n">qaid</span><span class="p">,</span> <span class="n">config2_</span><span class="o">=</span><span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_query_config2</span><span class="p">())[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c"># database forground weights</span>
        <span class="c"># avoid using K due to its more dynamic nature by using -Knorm</span>
        <span class="n">qfx2_dvec</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_vecs</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="o">-</span><span class="n">Knorm</span><span class="p">])</span>
        <span class="c"># Component-wise dot product + selectivity function</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="n">qfx2_cosweight</span> <span class="o">=</span> <span class="n">scoring</span><span class="o">.</span><span class="n">sift_selectivity_score</span><span class="p">(</span><span class="n">qfx2_qvec</span><span class="p">,</span> <span class="n">qfx2_dvec</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">cos_weight_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_cosweight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cos_weight_list</span>

</div>
<span class="nd">@_register_nn_simple_weight_func</span>
<div class="viewcode-block" id="fg_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.fg_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">fg_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    foreground feature match weighting</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.nn_weights --exec-fg_match_weighter</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; print(ut.dict_str(qreq_.qparams.__dict__, sorted_=True))</span>
<span class="sd">        &gt;&gt;&gt; assert qreq_.qparams.fg_on == True, &#39;bug setting custom params fg_on&#39;</span>
<span class="sd">        &gt;&gt;&gt; fgvotes_list = fg_match_weighter(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;fgvotes_list = %r&#39; % (fgvotes_list,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Knorm</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">Knorm</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_qaids</span><span class="p">()</span>
    <span class="n">config2_</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_query_config2</span><span class="p">()</span>
    <span class="c"># Database feature index to chip index</span>
    <span class="n">fgvotes_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">nns</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="c"># database forground weights</span>
        <span class="n">qfx2_dfgw</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_fgws</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="n">Knorm</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c"># query forground weights</span>
        <span class="n">qfx2_qfgw</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_fgweights</span><span class="p">([</span><span class="n">qaid</span><span class="p">],</span> <span class="n">ensure</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">config2_</span><span class="o">=</span><span class="n">config2_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># feature match forground weight</span>
        <span class="n">qfx2_fgvote_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qfx2_qfgw</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">qfx2_dfgw</span><span class="p">)</span>
        <span class="n">fgvotes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_fgvote_weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fgvotes_list</span>

</div>
<span class="nd">@_register_misc_weight_func</span>
<div class="viewcode-block" id="distinctiveness_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.distinctiveness_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">distinctiveness_match_weighter</span><span class="p">(</span><span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # SLOW_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;, codename=&#39;vsone_dist_extern_distinctiveness&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>

<span class="sd">    TODO: finish intergration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dstcnvs_normer</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">dstcnvs_normer</span>
    <span class="k">assert</span> <span class="n">dstcnvs_normer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_external_qaids</span><span class="p">()</span>
    <span class="n">vecs_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_vecs</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">config2_</span><span class="o">=</span><span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_query_config2</span><span class="p">())</span>
    <span class="n">dstcvs_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vecs</span> <span class="ow">in</span> <span class="n">vecs_list</span><span class="p">:</span>
        <span class="n">qfx2_vec</span> <span class="o">=</span> <span class="n">vecs</span>
        <span class="n">dstcvs</span> <span class="o">=</span> <span class="n">dstcnvs_normer</span><span class="o">.</span><span class="n">get_distinctiveness</span><span class="p">(</span><span class="n">qfx2_vec</span><span class="p">)</span>
        <span class="n">dstcvs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dstcvs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dstcvs_list</span>

</div>
<div class="viewcode-block" id="nn_normalized_weight"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.nn_normalized_weight">[docs]</a><span class="k">def</span> <span class="nf">nn_normalized_weight</span><span class="p">(</span><span class="n">normweight_fn</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic function to weight nearest neighbors</span>

<span class="sd">    ratio, lnbnn, and other nearest neighbor based functions use this</span>

<span class="sd">    Args:</span>
<span class="sd">        normweight_fn (func): chosen weight function e.g. lnbnn</span>
<span class="sd">        nns_list (dict): query descriptor nearest neighbors and distances. (qfx2_nnx, qfx2_dist)</span>
<span class="sd">        qreq_ (QueryRequest): hyper-parameters</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: weights_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = lnbnn_fn</span>
<span class="sd">        &gt;&gt;&gt; weights_list1 = nn_weights.nn_normalized_weight(normweight_fn, nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights1 = weights_list1[0]</span>
<span class="sd">        &gt;&gt;&gt; nn_normonly_weight = nn_weights.NN_WEIGHT_FUNC_DICT[&#39;lnbnn&#39;]</span>
<span class="sd">        &gt;&gt;&gt; weights_list2 = nn_normonly_weight(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights2 = weights_list2[0]</span>
<span class="sd">        &gt;&gt;&gt; assert np.all(weights1 == weights2)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_inbounds(weights1.sum(), 200, 300)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(&#39;PZ_MTEST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = ratio_fn</span>
<span class="sd">        &gt;&gt;&gt; weights_list1 = nn_weights.nn_normalized_weight(normweight_fn, nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights1 = weights_list1[0]</span>
<span class="sd">        &gt;&gt;&gt; nn_normonly_weight = nn_weights.NN_WEIGHT_FUNC_DICT[&#39;ratio&#39;]</span>
<span class="sd">        &gt;&gt;&gt; weights_list2 = nn_normonly_weight(nns_list, nnvalid0_list, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; weights2 = weights_list2[0]</span>
<span class="sd">        &gt;&gt;&gt; assert np.all(weights1 == weights2)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_inbounds(weights1.sum(), 2700, 4000)</span>

<span class="sd">    Ignore:</span>
<span class="sd">        #from ibeis.model.hots import neighbor_index as hsnbrx</span>
<span class="sd">        #nnindexer = hsnbrx.request_ibeis_nnindexer(qreq_)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#utool.stash_testdata(&#39;nns_list&#39;)</span>
    <span class="c">#</span>
    <span class="c">#Knorm = qreq_.qparams.Knorm</span>
    <span class="n">Knorm</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">Knorm</span>
    <span class="n">normalizer_rule</span>  <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">normalizer_rule</span>
    <span class="c">#with_metadata = qreq_.qparams.with_metadata</span>
    <span class="c">#normweight_upper_bound = 30  # TODO:  make this specific to each normweight func</span>

    <span class="c"># Prealloc output</span>
    <span class="n">weight_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c">#if with_metadata:</span>
    <span class="c">#    metadata = qreq_.metadata</span>
    <span class="c">#    metakey = ut.get_funcname(normweight_fn) + &#39;_norm_meta&#39;</span>
    <span class="c">#    metadata[metakey] = {}</span>
    <span class="c">#    metakey_metadata = metadata[metakey]</span>
    <span class="c">#else:</span>
    <span class="c">#    metakey_metadata = None</span>
    <span class="c"># Database feature index to chip index</span>
    <span class="n">qaid_list</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_internal_qaids</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">nns</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qaid_list</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">):</span>
        <span class="p">(</span><span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">)</span> <span class="o">=</span> <span class="n">nns</span>
        <span class="c"># Apply normalized weights</span>
        <span class="n">qfx2_normweight</span> <span class="o">=</span> <span class="n">apply_normweight</span><span class="p">(</span>
            <span class="n">normweight_fn</span><span class="p">,</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">,</span> <span class="n">normalizer_rule</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
        <span class="c">#with_metadata, metakey_metadata)</span>
        <span class="c">#qfx2_normweight[qfx2_normweight &gt; normweight_upper_bound] = normweight_upper_bound</span>
        <span class="c">#qfx2_normweight /= normweight_upper_bound</span>
        <span class="c"># Output</span>
        <span class="n">weight_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qfx2_normweight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weight_list</span>

</div>
<div class="viewcode-block" id="apply_normweight"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.apply_normweight">[docs]</a><span class="k">def</span> <span class="nf">apply_normweight</span><span class="p">(</span><span class="n">normweight_fn</span><span class="p">,</span> <span class="n">qaid</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">,</span> <span class="n">qfx2_dist</span><span class="p">,</span> <span class="n">normalizer_rule</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span>
                     <span class="n">qreq_</span><span class="p">):</span>
    <span class="c">#, with_metadata, metakey_metadata):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper: applies the normalized weight function to one query annotation</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: qfx2_normweight</span>

<span class="sd">    Args:</span>
<span class="sd">        normweight_fn (func):  chosen weight function e.g. lnbnn</span>
<span class="sd">        qaid (int):  query annotation id</span>
<span class="sd">        qfx2_idx (ndarray[int32_t, ndims=2]):  mapping from query feature index to db neighbor index</span>
<span class="sd">        qfx2_dist (ndarray):  mapping from query feature index to dist</span>
<span class="sd">        normalizer_rule (str):</span>
<span class="sd">        Knorm (int):</span>
<span class="sd">        qreq_ (QueryRequest):  query request object with hyper-parameters</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.nn_weights --test-apply_normweight</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; cfgdict = {&#39;K&#39;:10, &#39;Knorm&#39;: 10, &#39;normalizer_rule&#39;: &#39;name&#39;}</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(cfgdict=cfgdict)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; qaid = qreq_.get_external_qaids()[0]</span>
<span class="sd">        &gt;&gt;&gt; Knorm = qreq_.qparams.Knorm</span>
<span class="sd">        &gt;&gt;&gt; normweight_fn = lnbnn_fn</span>
<span class="sd">        &gt;&gt;&gt; normalizer_rule  = qreq_.qparams.normalizer_rule</span>
<span class="sd">        &gt;&gt;&gt; (qfx2_idx, qfx2_dist) = nns_list[0]</span>
<span class="sd">        &gt;&gt;&gt; qfx2_normweight = nn_weights.apply_normweight(normweight_fn, qaid, qfx2_idx,</span>
<span class="sd">        ...         qfx2_dist, normalizer_rule, Knorm, qreq_)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_inbounds(qfx2_normweight.sum(), 800, 950)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">Knorm</span>
    <span class="k">assert</span> <span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;K cannot be 0&#39;</span>
    <span class="n">qfx2_nndist</span> <span class="o">=</span> <span class="n">qfx2_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">K</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">normalizer_rule</span> <span class="o">==</span> <span class="s">&#39;last&#39;</span><span class="p">:</span>
        <span class="c"># Normalizers for &#39;last&#39; normalizer_rule</span>
        <span class="n">qfx2_normk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qfx2_dist</span><span class="p">),</span> <span class="n">hstypes</span><span class="o">.</span><span class="n">FK_DTYPE</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">Knorm</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">normalizer_rule</span> <span class="o">==</span> <span class="s">&#39;name&#39;</span><span class="p">:</span>
        <span class="c"># Normalizers for &#39;name&#39; normalizer_rule</span>
        <span class="n">qfx2_normk</span> <span class="o">=</span> <span class="n">get_name_normalizers</span><span class="p">(</span><span class="n">qaid</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">normalizer_rule</span> <span class="o">==</span> <span class="s">&#39;external&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;[nn_weights] no normalizer_rule=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">normalizer_rule</span><span class="p">)</span>
    <span class="n">qfx2_normdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dists</span><span class="p">[</span><span class="n">normk</span><span class="p">]</span>
                              <span class="k">for</span> <span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">normk</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qfx2_dist</span><span class="p">,</span> <span class="n">qfx2_normk</span><span class="p">)])</span>
    <span class="c">#qfx2_normidx  = np.array([idxs[normk]</span>
    <span class="c">#                          for (idxs, normk) in zip(qfx2_idx, qfx2_normk)])</span>
    <span class="c"># Ensure shapes are valid</span>
    <span class="n">qfx2_normdist</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">vdist</span> <span class="o">=</span> <span class="n">qfx2_nndist</span>    <span class="c"># voting distance</span>
    <span class="n">ndist</span> <span class="o">=</span> <span class="n">qfx2_normdist</span>  <span class="c"># normalizer distance</span>
    <span class="n">qfx2_normweight</span> <span class="o">=</span> <span class="n">normweight_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">)</span>
    <span class="c"># build meta</span>
    <span class="c">#if with_metadata:</span>
    <span class="c">#    normmeta_header = (&#39;normalizer_metadata&#39;, [&#39;norm_aid&#39;, &#39;norm_fx&#39;, &#39;norm_k&#39;])</span>
    <span class="c">#    qfx2_normmeta = np.array(</span>
    <span class="c">#        [</span>
    <span class="c">#            (qreq_.indexer.get_nn_aids(idx), qreq_.indexer.get_nn_featxs(idx), normk)</span>
    <span class="c">#            for (normk, idx) in zip(qfx2_normk, qfx2_normidx)</span>
    <span class="c">#        ]</span>
    <span class="c">#    )</span>
    <span class="c">#    metakey_metadata[qaid] = (normmeta_header, qfx2_normmeta)</span>
    <span class="k">return</span> <span class="n">qfx2_normweight</span>

</div>
<div class="viewcode-block" id="get_name_normalizers"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.get_name_normalizers">[docs]</a><span class="k">def</span> <span class="nf">get_name_normalizers</span><span class="p">(</span><span class="n">qaid</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">Knorm</span><span class="p">,</span> <span class="n">qfx2_idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper: normalizers for &#39;name&#39; normalizer_rule</span>

<span class="sd">    Args:</span>
<span class="sd">        qaid (int): query annotation id</span>
<span class="sd">        qreq_ (QueryRequest): hyper-parameters</span>
<span class="sd">        Knorm (int):</span>
<span class="sd">        qfx2_idx (ndarray):</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray : qfx2_normk</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots import nn_weights</span>
<span class="sd">        &gt;&gt;&gt; cfgdict = {&#39;K&#39;:10, &#39;Knorm&#39;: 10, &#39;normalizer_rule&#39;: &#39;name&#39;}</span>
<span class="sd">        &gt;&gt;&gt; tup = plh.testdata_pre_weight_neighbors(cfgdict=cfgdict)</span>
<span class="sd">        &gt;&gt;&gt; ibs, qreq_, nns_list, nnvalid0_list = tup</span>
<span class="sd">        &gt;&gt;&gt; Knorm = qreq_.qparams.Knorm</span>
<span class="sd">        &gt;&gt;&gt; (qfx2_idx, qfx2_dist) = nns_list[0]</span>
<span class="sd">        &gt;&gt;&gt; qaid = qreq_.get_external_qaids()[0]</span>
<span class="sd">        &gt;&gt;&gt; qfx2_normk = get_name_normalizers(qaid, qreq_, Knorm, qfx2_idx)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">Knorm</span> <span class="o">==</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">Knorm</span><span class="p">,</span> <span class="s">&#39;inconsistency in qparams&#39;</span>
    <span class="c"># Get the top names you do not want your normalizer to be from</span>
    <span class="n">qnid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">qaid</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">Knorm</span>
    <span class="k">assert</span> <span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;K cannot be 0&#39;</span>
    <span class="c"># Get the 0th - Kth matching neighbors</span>
    <span class="n">qfx2_topidx</span> <span class="o">=</span> <span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">K</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="c"># Get tke Kth - KNth normalizing neighbors</span>
    <span class="n">qfx2_normidx</span> <span class="o">=</span> <span class="n">qfx2_idx</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="n">Knorm</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span>
    <span class="c"># Apply temporary uniquish name</span>
    <span class="n">qfx2_topaid</span>  <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_aids</span><span class="p">(</span><span class="n">qfx2_topidx</span><span class="p">)</span>
    <span class="n">qfx2_normaid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">get_nn_aids</span><span class="p">(</span><span class="n">qfx2_normidx</span><span class="p">)</span>
    <span class="n">qfx2_topnid</span>  <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">qfx2_topaid</span><span class="p">)</span>
    <span class="n">qfx2_normnid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">ibs</span><span class="o">.</span><span class="n">get_annot_name_rowids</span><span class="p">(</span><span class="n">qfx2_normaid</span><span class="p">)</span>
    <span class="c"># Inspect the potential normalizers</span>
    <span class="n">qfx2_selnorm</span> <span class="o">=</span> <span class="n">mark_name_valid_normalizers</span><span class="p">(</span><span class="n">qnid</span><span class="p">,</span> <span class="n">qfx2_topnid</span><span class="p">,</span> <span class="n">qfx2_normnid</span><span class="p">)</span>
    <span class="n">qfx2_normk</span> <span class="o">=</span> <span class="n">qfx2_selnorm</span> <span class="o">+</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="n">Knorm</span><span class="p">)</span>  <span class="c"># convert form negative to pos indexes</span>
    <span class="k">return</span> <span class="n">qfx2_normk</span>

</div>
<div class="viewcode-block" id="mark_name_valid_normalizers"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.mark_name_valid_normalizers">[docs]</a><span class="k">def</span> <span class="nf">mark_name_valid_normalizers</span><span class="p">(</span><span class="n">qnid</span><span class="p">,</span> <span class="n">qfx2_topnid</span><span class="p">,</span> <span class="n">qfx2_normnid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    helper: Allows matches only to the first result of a given name</span>

<span class="sd">    Each query feature finds its K matches and Kn normalizing matches. These are the</span>
<span class="sd">    candidates from which it can choose a set of matches and a single normalizer.</span>

<span class="sd">    A normalizer is marked as invalid if it belongs to a name that was also in its</span>
<span class="sd">    feature&#39;s candidate matching set.</span>


<span class="sd">    Args:</span>
<span class="sd">        qfx2_topnid (ndarray): marks the names a feature matches</span>
<span class="sd">        qfx2_normnid (ndarray): marks the names of the feature normalizers</span>
<span class="sd">        qnid (int): query name id</span>

<span class="sd">    Ignore:</span>
<span class="sd">        print(ut.doctest_repr(qfx2_normnid, &#39;qfx2_normnid&#39;, verbose=False))</span>
<span class="sd">        print(ut.doctest_repr(qfx2_topnid, &#39;qfx2_topnid&#39;, verbose=False))</span>


<span class="sd">    Returns:</span>
<span class="sd">        qfx2_selnorm - index of the selected normalizer for each query feature</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m ibeis.model.hots.nn_weights --exec-mark_name_valid_normalizers</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; qnid = 1</span>
<span class="sd">        &gt;&gt;&gt; qfx2_topnid = np.array([[1, 1, 1, 1, 1],</span>
<span class="sd">        ...                         [1, 2, 1, 1, 1],</span>
<span class="sd">        ...                         [1, 2, 2, 3, 1],</span>
<span class="sd">        ...                         [5, 8, 9, 8, 8],</span>
<span class="sd">        ...                         [5, 8, 9, 8, 8],</span>
<span class="sd">        ...                         [6, 6, 9, 6, 8],</span>
<span class="sd">        ...                         [5, 8, 6, 6, 6],</span>
<span class="sd">        ...                         [1, 2, 8, 6, 6]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; qfx2_normnid = np.array([[ 1, 1, 1],</span>
<span class="sd">        ...                          [ 2, 3, 1],</span>
<span class="sd">        ...                          [ 2, 3, 1],</span>
<span class="sd">        ...                          [ 6, 6, 6],</span>
<span class="sd">        ...                          [ 6, 6, 8],</span>
<span class="sd">        ...                          [ 2, 6, 6],</span>
<span class="sd">        ...                          [ 6, 6, 1],</span>
<span class="sd">        ...                          [ 4, 4, 9]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; qfx2_selnorm = mark_name_valid_normalizers(qnid, qfx2_topnid, qfx2_normnid)</span>
<span class="sd">        &gt;&gt;&gt; K = len(qfx2_topnid.T)</span>
<span class="sd">        &gt;&gt;&gt; Knorm = len(qfx2_normnid.T)</span>
<span class="sd">        &gt;&gt;&gt; qfx2_normk_ = qfx2_selnorm + (Knorm)  # convert form negative to pos indexes</span>
<span class="sd">        &gt;&gt;&gt; result = str(qfx2_normk_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [2 1 2 0 0 0 2 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Your normalizer should be from a name that is not in any of the top</span>
    <span class="c"># matches if possible. If not possible it should be from the name with the</span>
    <span class="c"># highest k value.</span>

    <span class="c">#%timeit np.vstack([vt.get_uncovered_mask(normnids, topnids) for topnids, normnids in zip(qfx2_topnid, qfx2_normnid)])</span>
    <span class="c">#%timeit vt.compare_matrix_columns(qfx2_normnid, qfx2_topnid)</span>
    <span class="c">#&quot;&quot;&quot; matrix = qfx2_normnid; columns = qfx2_topnid; row_matrix = matrix.T; row_list = columns.T; &quot;&quot;&quot;</span>
    <span class="c"># Find the positions in the normalizers that could be valid (assumes Knorm &gt; 1)</span>
    <span class="c"># wow, this actually seems to work an is efficient. I hardly understand the code I write.</span>
    <span class="c"># takes each column in topnid and comparses it to each column in in qfx2_normnid</span>
    <span class="c"># Taking the logical or of all of these results gives you a matrix with the</span>
    <span class="c"># shape of qfx2_normnid that is True where a normalizing feature&#39;s name</span>
    <span class="c"># appears anywhere in the corresponding row of qfx2_topnid</span>
    <span class="n">qfx2_invalid</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">compare_matrix_columns</span><span class="p">(</span>
        <span class="n">qfx2_normnid</span><span class="p">,</span> <span class="n">qfx2_topnid</span><span class="p">,</span>
        <span class="n">comp_op</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">,</span>
        <span class="n">logic_op</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">)</span>
    <span class="n">qfx2_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">qfx2_invalid</span><span class="p">)</span>

    <span class="c">#if qnid is not None:</span>
    <span class="c"># Mark self as invalid, if given that information</span>
    <span class="n">qfx2_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">qfx2_normnid</span> <span class="o">!=</span> <span class="n">qnid</span><span class="p">,</span> <span class="n">qfx2_valid</span><span class="p">)</span>

    <span class="c"># TODO: warn if any([np.any(flags) for flags in qfx2_invalid]), &#39;Normalizers are potential matches. Increase Knorm&#39;</span>

    <span class="c"># For each query feature find its best normalizer (using negative indices)</span>
    <span class="n">Knorm</span> <span class="o">=</span> <span class="n">qfx2_normnid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">qfx2_validxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">normrow</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">normrow</span> <span class="ow">in</span> <span class="n">qfx2_valid</span><span class="p">]</span>
    <span class="n">qfx2_selnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">validxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Knorm</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">validxs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span>
                             <span class="n">validxs</span> <span class="ow">in</span> <span class="n">qfx2_validxs</span><span class="p">],</span> <span class="n">hstypes</span><span class="o">.</span><span class="n">FK_DTYPE</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qfx2_selnorm</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="lnbnn_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.lnbnn_fn">[docs]</a><span class="k">def</span> <span class="nf">lnbnn_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Locale Naive Bayes Nearest Neighbor weighting</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; ndists = np.array([[0, 1, 2], [3, 4, 5], [3, 4, 5], [3, 4, 5],  [9, 7, 6]])</span>
<span class="sd">        &gt;&gt;&gt; ndist = ndists.T[0:1].T</span>
<span class="sd">        &gt;&gt;&gt; vdist = np.array([[3, 2, 1, 5], [3, 2, 5, 6], [3, 4, 5, 3], [3, 4, 5, 8],  [9, 7, 6, 3] ])</span>
<span class="sd">        &gt;&gt;&gt; vdist1 = vdist[:, 0:1]</span>
<span class="sd">        &gt;&gt;&gt; vdist2 = vdist[:, 0:2]</span>
<span class="sd">        &gt;&gt;&gt; vdist3 = vdist[:, 0:3]</span>
<span class="sd">        &gt;&gt;&gt; vdist4 = vdist[:, 0:4]</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist1, ndist))</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist2, ndist))</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist3, ndist))</span>
<span class="sd">        &gt;&gt;&gt; print(lnbnn_fn(vdist4, ndist))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ndist</span> <span class="o">-</span> <span class="n">vdist</span><span class="p">)</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="loglnbnn_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.loglnbnn_fn">[docs]</a><span class="k">def</span> <span class="nf">loglnbnn_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ndist</span> <span class="o">-</span> <span class="n">vdist</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c"># / 1000.0</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="ratio_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.ratio_fn">[docs]</a><span class="k">def</span> <span class="nf">ratio_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        vdist (ndarray): voting array</span>
<span class="sd">        ndist (ndarray): normalizing array</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: out</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; vdist = np.array([[ 0.,  0.,  0.,  0.,  0.,  0.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; ndist = np.array([[  60408.,   61594.,  111387., 120138., 124307.,  125625.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; out = ratio_fn(vdist, ndist)</span>
<span class="sd">        &gt;&gt;&gt; result = np.array_repr(out.T, precision=2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        array([[ 0.,  0.,  0.,  0.,  0.,  0.]], dtype=float32)</span>

<span class="sd">    Example2:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from ibeis.model.hots.nn_weights import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; vdist = np.array([[  79260.,  138617.,   47964.,  127839.,  123543.,  112204.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; ndist = np.array([[  83370.,  146245.,  128620.,  129598.,  126165.,  124761.]], dtype=np.float32).T</span>
<span class="sd">        &gt;&gt;&gt; out = ratio_fn(vdist, ndist)</span>
<span class="sd">        &gt;&gt;&gt; result = np.array_repr(out.T, precision=2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        array([[ 0.95,  0.95,  0.37,  0.99,  0.98,  0.9 ]], dtype=float32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">)</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="dist_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.dist_fn">[docs]</a><span class="k">def</span> <span class="nf">dist_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; just use straight up distance &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vdist</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="bar_l2_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.bar_l2_fn">[docs]</a><span class="k">def</span> <span class="nf">bar_l2_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; one - distnce. no normalizer &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">vdist</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="logratio_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.logratio_fn">[docs]</a><span class="k">def</span> <span class="nf">logratio_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">ndist</span><span class="p">,</span> <span class="n">vdist</span> <span class="o">+</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

</div>
<span class="nd">@_register_nn_normalized_weight_func</span>
<div class="viewcode-block" id="normonly_fn"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.normonly_fn">[docs]</a><span class="k">def</span> <span class="nf">normonly_fn</span><span class="p">(</span><span class="n">vdist</span><span class="p">,</span> <span class="n">ndist</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ndist</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vdist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c">#return ndist[None, 0:1]</span>


<span class="c">#@_register_nn_simple_weight_func</span></div>
<div class="viewcode-block" id="gravity_match_weighter"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.gravity_match_weighter">[docs]</a><span class="k">def</span> <span class="nf">gravity_match_weighter</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;have not finished gv weighting&#39;</span><span class="p">)</span>
    <span class="c">#qfx2_nnkpts = qreq_.indexer.get_nn_kpts(qfx2_nnidx)</span>
    <span class="c">#qfx2_nnori = ktool.get_oris(qfx2_nnkpts)</span>
    <span class="c">#qfx2_kpts  = qreq_.ibs.get_annot_kpts(qaid, config2_=qreq_.get_internal_query_config2())  # FIXME: Highly inefficient</span>
    <span class="c">#qfx2_oris  = ktool.get_oris(qfx2_kpts)</span>
    <span class="c">## Get the orientation distance</span>
    <span class="c">#qfx2_oridist = vt.rowwise_oridist(qfx2_nnori, qfx2_oris)</span>
    <span class="c">## Normalize into a weight (close orientations are 1, far are 0)</span>
    <span class="c">#qfx2_gvweight = (TAU - qfx2_oridist) / TAU</span>
    <span class="c">## Apply gravity vector weight to the score</span>
    <span class="c">#qfx2_score *= qfx2_gvweight</span>

</div>
<div class="viewcode-block" id="test_all_normalized_weights"><a class="viewcode-back" href="../../../../ibeis.model.hots.html#ibeis.model.hots.nn_weights.test_all_normalized_weights">[docs]</a><span class="k">def</span> <span class="nf">test_all_normalized_weights</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; test_all_normalized_weights()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">nn_weights</span>
    <span class="kn">import</span> <span class="nn">six</span>
    <span class="n">ibs</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span> <span class="o">=</span> <span class="n">plh</span><span class="o">.</span><span class="n">testdata_pre_weight_neighbors</span><span class="p">()</span>
    <span class="n">qaid</span> <span class="o">=</span> <span class="n">qreq_</span><span class="o">.</span><span class="n">get_external_qaids</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">test_weight_fn</span><span class="p">(</span><span class="n">nn_weight</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">qaid</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">ibeis.model.hots</span> <span class="kn">import</span> <span class="n">nn_weights</span>
        <span class="c">#----</span>
        <span class="n">normweight_fn</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">nn_weight</span> <span class="o">+</span> <span class="s">&#39;_fn&#39;</span><span class="p">]</span>
        <span class="n">weight_list1</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">nn_normalized_weight</span><span class="p">(</span><span class="n">normweight_fn</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
        <span class="n">weights1</span> <span class="o">=</span> <span class="n">weight_list1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#---</span>
        <span class="c"># test NN_WEIGHT_FUNC_DICT</span>
        <span class="c">#---</span>
        <span class="n">nn_normonly_weight</span> <span class="o">=</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">[</span><span class="n">nn_weight</span><span class="p">]</span>
        <span class="n">weight_list2</span> <span class="o">=</span> <span class="n">nn_normonly_weight</span><span class="p">(</span><span class="n">nns_list</span><span class="p">,</span> <span class="n">nnvalid0_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">)</span>
        <span class="n">weights2</span> <span class="o">=</span> <span class="n">weight_list2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">weights1</span> <span class="o">==</span> <span class="n">weights2</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">nn_weight</span> <span class="o">+</span> <span class="s">&#39; passed&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">nn_weight</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">nn_weights</span><span class="o">.</span><span class="n">NN_WEIGHT_FUNC_DICT</span><span class="p">):</span>
        <span class="n">normweight_key</span> <span class="o">=</span> <span class="n">nn_weight</span> <span class="o">+</span> <span class="s">&#39;_fn&#39;</span>
        <span class="k">if</span> <span class="n">normweight_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nn_weights</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">test_weight_fn</span><span class="p">(</span><span class="n">nn_weight</span><span class="p">,</span> <span class="n">nns_list</span><span class="p">,</span> <span class="n">qreq_</span><span class="p">,</span> <span class="n">qaid</span><span class="p">)</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    python -m ibeis.model.hots.nn_weights --allexamples</span>
<span class="sd">    python -m ibeis.model.hots.nn_weights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>  <span class="c"># NOQA</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Jon Crall.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'1.4.4',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>